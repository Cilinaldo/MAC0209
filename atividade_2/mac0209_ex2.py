# -*- coding: utf-8 -*-
"""MAC0209-Ex2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eG41ks96W9td4ZliuyMcUhCL1x0Utfc3
"""

import matplotlib.pyplot as plt

from datetime import datetime
import json

import warnings

import numpy as np

from pyproj import Proj, transform

"""# para ignorar todos os warnings"""
# warnings.filterwarnings('ignore')

"""# O formato JSON
Referência: [json.org](https://www.json.org/json-en.html)

JSON é uma notação usada para criar mensagens de texto estruturadas. A ideia/motivação principal é que sejam simples de serem lidas por seres humanos e ao mesmo tempo fáceis de serem geradas/lidas por um programa (parser).

Um mensagem no formato JSON conta com duas estruturas básicas: (1) uma coleção de pares chave/valor delimitados por chaves '{}' (similar à dicionários em python); e (2) uma sequência de elementos, que são delimitados por colchetes '[]' (similar à listas em python).

Uma coleção de pares chave/valor é chamada de objeto, a chave em cada par chave/valor deve ser uma string e um objeto não pode ter duas chaves iguais.

Uma sequência não possui chaves e seus elementos podem ser mistos (por exemplo: outras sequências, objetos e elementos).

Um elemento pode ser ou uma string delimitada por aspas duplas "exemplo de string" ou um número.

Todos os exemplos a seguir são mensagens válidas de acordo com o formato JSON:

1. ""
2. "JSON válido"
3. []
4. ["A sequancia anterior está vazia", "Já esta aqui tem duas strings e um número", 7]
5. {"chave": "valor da chave para este objeto"}
6. {}
7. "A linha anterior tem um objeto vazio"

Apesar da notação admitir mensagens com apenas uma string, números, ou sequência, muitas vezes aplicações que dão suporte ao formato JSON não admitem mensagens que não contenham um objeto principal, isso é, todos os elementos da mensagem são encapsulados num objeto raiz, por exemplo:

{
  "c1": {"chave nutela": "objeto interno", "id" : 7},
  "outra chave": 2,
  "alguma sequencia importante": [2,3,5,7,11]
}

Note que além de termos um objeto principal na mensagem anterior (delimitado pelas chaves na primeira e ultima linha) temos outro objeto no primeiro par chave/valor (com a chave "c1"). Cada par chave/valor num objeto deve ser separado por vírgulas de outros pares no mesmo objeto.

Existem diversos [editores online de JSON](https://jsoneditoronline.org/#left=local.nijuma&right=local.pisura) que podemos usar para explorar mensagens JSON rapidamente, ou para entender como o formato funciona.

# Carregando o arquivo de dados do KartaView

Vamos agora analisar os dados coletados através da plataforma KartaView, como explicado em aula. 

Esses dados estão formatados usando-se o formato JSON de JavaScript Object Notation.
"""




arquivo_json = "sample1.json"

with open(arquivo_json, "r") as f:
    pontos = f.read()
    pontos = json.loads(pontos)

print(f"Chaves na raiz - \n{pontos.keys()}\n")
print(f"Chaves do objeto na chave 'status' - \n{pontos['status'].keys()}\n")
print(f"Chaves do objeto na chave 'osv' - \n{pontos['osv'].keys()}")

"""Seguindo a sequencia de chaves 'osv' -> 'photos' chegamos à uma sequência de objetos.

Cada um destes objetos representa os metadados de uma imagem tomada em um ponto do trajeto escolhido no KartaView.
"""

# Exemplo de um objeto na chave 'photos':
pontos['osv']['photos'][0]

"""Podemos observar que muitos dos campos parecem ter utilidade apenas para a aplicação do KartaView.

Para simplificar a análise vamos criar um novo arquivo JSON (chamado extractedque contenha um único objeto raiz com um único par chave/valor. Este par será o campo 'photos' e a sequência para a qual ele é chave:

`{
"photos" :
    [
    {
        'id': '206416139',
         'sequence_id': '1131993',
         'sequence_index': '0',
         'lat': '32.188423',
         'lng': '-81.195239',
         'fileName': '1131993_119db_1.jpg',
         'name': 'storage7/files/photo/2018/3/4/proc/1131993_119db_1.jpg',
         'lth_name': 'storage7/files/photo/2018/3/4/lth/1131993_119db_1.jpg',
         'th_name': 'storage7/files/photo/2018/3/4/th/1131993_119db_1.jpg',
         'path': '2018/3/4',
         ...
     },
     ...
    ]
}`

"""

from photos_extract import make_extract_photos_JSON, get_photo_array_positions, clean_extracted

jsonfile = 'sample1.json'

extracted_filename = "extracted_" + jsonfile
cleaned_filename = "cleaned_" + jsonfile

with open(jsonfile, "r") as jf:
        # Aqui o array 'photos' é extraído e colocado 
        # em outro arquivo (com o prefixo extracted_),
        # para facilitar o processamento do array.
        #
        # Em seguida usamos a função clean_extracted para
        # criar um terceiro arquivo (com prefixo _cleaned)
        # que contenha somente os campos de interesse para
        # a análise.
        txt = jf.read()
        extracted_str = make_extract_photos_JSON(extracted_filename, txt)

        with open(jsonfile, "r") as jf:
            # Aqui o array 'photos' é extraído e colocado
            # em outro arquivo (com o prefixo extracted_),
            # para facilitar o processamento do array.
            #
            # Em seguida usamos a função clean_extracted para
            # criar um terceiro arquivo (com prefixo _cleaned)
            # que contenha somente os campos de interesse para
            # a análise.
            txt = jf.read()

            with open(cleaned_filename, "w") as cjf:
                cjf.write(json.dumps(clean_extracted(extracted_str)))

"""### Exercício

Usando o arquivo 'extracted_sample1.json' gerado na seção anterior crie um novo arquivo JSON chamado 'cleaned_sample1.json' em que cada objeto da sequência 'photos' contém somente os campos:

- 'lat'
- 'lng'
- 'heading'
- 'shot_date'

Ou seja, o novo arquivo gerado a partir do 'extracted_sample1.json' deverá seguir o modelo:

`{
"photos" :
    [
    {
        'lat': '32.188423',
        'lng' : '-81.195239',
        'heading' : '72.76266',
        'shot_date': '2018-03-03 20:29:36'
     },
     ...
    ]
}`

# Definindo uma faixa de pontos

O trajeto pode conter muitos pontos (e.g. 7800+ no JSON anterior). Para facilitar a nossa vida e a análise, vamos selecionar um conjunto menor de pontos para este exercício.
"""

# Vamos carregar os pontos (do JSON filtrado) na variável pontos.
arquivo_pontos = "cleaned_sample1.json"

with open(arquivo_pontos, "r") as f:
    pontos = f.read()
    pontos = json.loads(pontos)
    pontos = pontos['photos']

# Aqui escolhemos quais pontos iremos usar no intervalo entre [0-7847]
faixa_de_pontos = range(1000, 1100)

# Um ponto da rota escolhida é um objeto com as seguintes propriedades
pontos[faixa_de_pontos[0]]

"""# Medindo distâncias

## Funções auxiliares

Para facilitar um pouco a escrita do código e termos um código focado
no problema que queremos resolver, ao invés de nos preocuparmos com
detalhes da estrutura interna dos dados, vamos definir aqui algumas
funções auxiliares com a responsabilidade exclusiva de coletar uma propriedade específica da lista de pontos, possivelmente tratando o dado coletado.

### def get_point_coords(index, points_object)

Essa função irá nos auxiliar para coletar as coordenadas (e.g. longitude e latitude) de um ponto (na posição 'index') da lista de pontos passado também como parâmetro da função.

Note que as coordenadas dos pontos (no arquivo de dados) usam a projeção EPSG:4326, isso significa que estas coordenadas são ângulos e portanto precisamos fazer uma conversão, ou mais precisamente uma (re)projeção em um outro sistema de coordenadas (i.e. CRS) que use unidades métricas (e.g. metros).
"""

def get_point_coords(index, points_object):
    """
    Essa função recebe um índice numérico correspondendo a uma
    posição na lista de pontos "points_object".
    
    Ela retorna um vetor do numpy com a longitude e latitude
    (propriedades 'lng' e 'lat') do ponto na posição 'index'.
    """
    lat = points_object[index]['lat']
    lat = float(lat)
    lng = points_object[index]['lng']
    lng = float(lng)
    return np.array((lng, lat))

"""### def get_point_coords_proj(index, points_object)

Essa função auxiliar faz exatamente o mesmo que a anterior, contudo os pontos aqui são reprojetados para a projeção EPSG:3857, que usa como unidade métrica o 'metro' ao invés de graus de ângulo.
"""

def get_point_coords_proj(index, points_object):
    """
    Essa função é similar a get_point_coords, ela 
    recebe um índice numérico correspondendo a uma
    posição na lista de pontos "points_object".
    
    Contudo esta os pontos na projeção EPSG:3857 em
    que a unidade de medida é em metros e portanto
    podemos calcular a distância euclidiana entre dois
    pontos com base em suas coordenadas.
    
    Os pontos retornados são um vetor numpy em que
    a primeira posição é uma medida em metros no eixo
    horizontal e a segunda é num eixo vertical.
    O ponto de origem pode ser visto aqui https://epsg.io/3857
    """
    
    lat = points_object[index]['lat']
    lat = float(lat)
    lng = points_object[index]['lng']
    lng = float(lng)
    p = np.array((lng, lat))
    p = transform(Proj(init='epsg:4326'), Proj(init='epsg:3857'), p[0], p[1])
    return p

"""### def get_shot_time(index, points_object)

Esta função é um acessor para a propriedade 'shot_date' na lista de pontos. Essa propriedade indica o momento (dia e hora incluindo segundos) em que o ponto foi criado.
"""

FMT = '%Y-%m-%d %H:%M:%S'
def get_shot_time(index, points_object):
    """
    Retorna a data e hora em que o ponto 'index',
    da lista de pontos 'points_object', foi criado.
    
    O formato de retorno é uma string '%Y-%m-%d %H:%M:%S'
    (e.g. 2018-03-03 20:55:32)
    """
    return points_object[index]['shot_date']

"""### Visualizando a distância percorrida no tempo
Note que o movimento não é perfeitamente uniforme em todos os momentos e note também que nem todos os momentos de tempo existem no conjunto de dados (e.g. lacunas entre dois 'segmentos de reta')

## Exemplo com 2 pontos

Aqui vamos medir distâncias entre dois pontos
para termos uma ideia de como usar as definições
e funções auxiliares definidas até aqui.

### Coordenadas em metros

Usamos a função auxiliar get_point_coords_proj, cujas coordenadas
de retorno usam unidades de medida em metros.
"""

pp1 = get_point_coords_proj(faixa_de_pontos[0], pontos)

pp2 = get_point_coords_proj(faixa_de_pontos[1], pontos)

# Note que aqui temos uma unidade de metros à leste
# (ou oeste em caso negativo) e à norte (ou sul
# em caso negativo) de um dado local no planeta.

print(f'easting pp1: {pp1[0]} m; northing pp1: {pp1[1]} m')
print(f'easting pp2: {pp2[0]} m; northing pp2: {pp2[1]} m')

"""## Exercício 2

### Medindo a distância entre dois pontos

Neste exercício você deve implementar a função distancia_euclidiana.

Esta função recebe dois vetores (i.e. array numpy) cada um com duas dimensões e retorna
a distância euclidiana entre eles.
"""

def distancia_euclidiana(v1, v2):
    """
    Tendo como parâmetros os vetores numpy 2D 'v1' e 'v2', crie uma
    função que retorne a distância euclidiana entre os dois vetores.
    """
    return ((v1[0]-v2[0])**2 + (v1[1]-v2[1])**2)**(1/2)

# Desta vez a distância resultante pode ser interpretada
# fisicamente em metros.

print(f'A distância entre pp1 e pp2 é: {distancia_euclidiana(pp1, pp2)} metros.')

# Teste artificial

pv1 = np.array([1, 1]) # Ponto x = 1, y = 1
pv2 = np.array([1, -1]) # Ponto x = 2, y = 0

print(f'A distância entre pv1 e pv2 é 2')
print(f'A distância retornada pela função implementada foi {distancia_euclidiana(pv1, pv2)}\n')
if distancia_euclidiana(pv1, pv2) == 2:
    print("A distância foi calculada corretamente")
else:
    print("A distância foi calculada incorretamente\n")
    print(f"O erro entre o esperado e o calculado foi {2 - distancia_euclidiana(pv1, pv2)}")

"""### Exercício - Visualizando o comprimento de cada trecho

Usando a função criada no exercício anterior vamos agora ver a distância percorrida pelo veículo a cada passo do sub-trajeto selecionado:

A ideia aqui é que todos os pontos da faixa de pontos selecionada sejam percorridos, e para cada par de pontos subsequentes seja calculada a distância entre eles e impressa essa distância.

Imprima uma lista como o exemplo a seguir usando a sua função de medir distância entre dois pontos:


- trecho 1000 a 1001 ; d = 0
- trecho 1001 a 1002 ; d = 0
- trecho 1002 a 1003 ; d = 0
- trecho 1003 a 1004 ; d = 0
- ...
- trecho 1097 a 1098 ; d = 0
- trecho 1098 a 1099 ; d = 0
- trecho 1099 a 1100 ; d = 0

Dica, você pode usar a linha abaixo para imprimir uma vez que a distância foi calculada:

`print(f'trecho {i} {i+1} ; d = {dist}')`
"""

for i in faixa_de_pontos:
    pp1 = get_point_coords_proj(i, pontos)
    pp2 = get_point_coords_proj(i+1, pontos)
    dist = distancia_euclidiana(pp1, pp2)
    print(f'trecho {i} a {i+1} ; d = {dist}')